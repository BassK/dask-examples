{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<img src=\"http://dask.readthedocs.io/en/latest/_images/dask_horizontal.svg\" \n",
    "     width=\"30%\" \n",
    "     align=right\n",
    "     alt=\"Dask logo\">\n",
    "\n",
    "# Embarrassingly parallel Workloads\n",
    "\n",
    "This notebook shows how to use Dask to parallelize embarrassingly parallel workloads where you want to apply one function to many pieces of data independently.  It will show three different ways of doing this with Dask:\n",
    "\n",
    "1. [dask.delayed](http://dask.pydata.org/en/latest/delayed.html) \n",
    "2. [concurrent.Futures](https://dask.pydata.org/en/latest/futures.html) \n",
    "3. [dask.bag](https://dask.pydata.org/en/latest/bag.html)\n",
    "\n",
    "This example focuses on using Dask for building large embarrassingly parallel computation as often seen in scientific communities and on High Performance Computing facilities, for example with Monte Carlo methods. This kind of simulation assume the following:\n",
    "\n",
    " - We have a function that runs a heavy computation given some parameters.\n",
    " - We need to compute this function on many different input parameters, each function call being independent.\n",
    " - We want to gather all the results in one place for further analysis."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Start Dask Client for Dashboard\n",
    "\n",
    "Starting the Dask Client will provide a dashboard which \n",
    "is useful to gain insight on the computation.  We will also need it for the\n",
    "Futures API part of this example. Moreover, as this kind of computation\n",
    "is often launched on super computer or in the Cloud, you will probably end\n",
    "up having to start a cluster and connect a client to scale.  See \n",
    "[dask-jobqueue](https://github.com/dask/dask-jobqueue),\n",
    "[dask-kubernetes](https://github.com/dask/dask-kubernetes) or \n",
    "[dask-yarn](https://github.com/dask/dask-yarn) for easy ways to achieve this\n",
    "on respectively an HPC, Cloud or Big Data infrastructure.\n",
    "\n",
    "The link to the dashboard will become visible when you create the client below.  We recommend having it open on one side of your screen while using your notebook on the other side.  This can take some effort to arrange your windows, but seeing them both at the same time is very useful when learning."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-01-23T03:35:04.987915Z",
     "iopub.status.busy": "2021-01-23T03:35:04.987424Z",
     "iopub.status.idle": "2021-01-23T03:35:07.224770Z",
     "shell.execute_reply": "2021-01-23T03:35:07.225450Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/html": [
       "<table style=\"border: 2px solid white;\">\n",
       "<tr>\n",
       "<td style=\"vertical-align: top; border: 0px solid white\">\n",
       "<h3 style=\"text-align: left;\">Client</h3>\n",
       "<ul style=\"text-align: left; list-style: none; margin: 0; padding: 0;\">\n",
       "  <li><b>Scheduler: </b>tcp://127.0.0.1:34649</li>\n",
       "  <li><b>Dashboard: </b><a href='http://127.0.0.1:8787/status' target='_blank'>http://127.0.0.1:8787/status</a></li>\n",
       "</ul>\n",
       "</td>\n",
       "<td style=\"vertical-align: top; border: 0px solid white\">\n",
       "<h3 style=\"text-align: left;\">Cluster</h3>\n",
       "<ul style=\"text-align: left; list-style:none; margin: 0; padding: 0;\">\n",
       "  <li><b>Workers: </b>1</li>\n",
       "  <li><b>Cores: </b>4</li>\n",
       "  <li><b>Memory: </b>7.29 GB</li>\n",
       "</ul>\n",
       "</td>\n",
       "</tr>\n",
       "</table>"
      ],
      "text/plain": [
       "<Client: 'tcp://127.0.0.1:34649' processes=1 threads=4, memory=7.29 GB>"
      ]
     },
     "execution_count": 1,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "from dask.distributed import Client, progress\n",
    "client = Client(threads_per_worker=4, n_workers=1)\n",
    "client"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Define your computation calling function\n",
    "\n",
    "This function does a simple operation: add all numbers of a list/array together, but it also sleeps for a random amount of time to simulate real work. In real use cases, this could call another python module, or even run an executable using subprocess module."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-01-23T03:35:07.228358Z",
     "iopub.status.busy": "2021-01-23T03:35:07.227488Z",
     "iopub.status.idle": "2021-01-23T03:35:07.231493Z",
     "shell.execute_reply": "2021-01-23T03:35:07.232058Z"
    }
   },
   "outputs": [],
   "source": [
    "import time\n",
    "import random\n",
    "\n",
    "def costly_simulation(list_param):\n",
    "    time.sleep(random.random())\n",
    "    return sum(list_param)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We try it locally below"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-01-23T03:35:07.234618Z",
     "iopub.status.busy": "2021-01-23T03:35:07.233786Z",
     "iopub.status.idle": "2021-01-23T03:35:07.668614Z",
     "shell.execute_reply": "2021-01-23T03:35:07.668261Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "CPU times: user 2.47 ms, sys: 3.15 ms, total: 5.62 ms\n",
      "Wall time: 426 ms\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "10"
      ]
     },
     "execution_count": 3,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "%time costly_simulation([1, 2, 3, 4])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Define the set of input parameters to call the function\n",
    "\n",
    "We will generate a set of inputs on which we want to run our simulation function. Here we use Pandas dataframe, but we could also use a simple list. Lets say that our simulation is run with four parameters called param_[a-d]."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-01-23T03:35:07.676683Z",
     "iopub.status.busy": "2021-01-23T03:35:07.676259Z",
     "iopub.status.idle": "2021-01-23T03:35:07.683875Z",
     "shell.execute_reply": "2021-01-23T03:35:07.684441Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>param_a</th>\n",
       "      <th>param_b</th>\n",
       "      <th>param_c</th>\n",
       "      <th>param_d</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>0</th>\n",
       "      <td>0.141666</td>\n",
       "      <td>0.865837</td>\n",
       "      <td>0.374940</td>\n",
       "      <td>0.239484</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1</th>\n",
       "      <td>0.990379</td>\n",
       "      <td>0.394309</td>\n",
       "      <td>0.995493</td>\n",
       "      <td>0.249236</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>2</th>\n",
       "      <td>0.435076</td>\n",
       "      <td>0.206969</td>\n",
       "      <td>0.550991</td>\n",
       "      <td>0.506224</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3</th>\n",
       "      <td>0.603971</td>\n",
       "      <td>0.473573</td>\n",
       "      <td>0.643380</td>\n",
       "      <td>0.656359</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>4</th>\n",
       "      <td>0.535920</td>\n",
       "      <td>0.756906</td>\n",
       "      <td>0.116472</td>\n",
       "      <td>0.873428</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "    param_a   param_b   param_c   param_d\n",
       "0  0.141666  0.865837  0.374940  0.239484\n",
       "1  0.990379  0.394309  0.995493  0.249236\n",
       "2  0.435076  0.206969  0.550991  0.506224\n",
       "3  0.603971  0.473573  0.643380  0.656359\n",
       "4  0.535920  0.756906  0.116472  0.873428"
      ]
     },
     "execution_count": 4,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "\n",
    "input_params = pd.DataFrame(np.random.random(size=(500, 4)),\n",
    "                            columns=['param_a', 'param_b', 'param_c', 'param_d'])\n",
    "input_params.head()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Without using Dask, we could call our simulation on all of these parameters using normal Python for loops.\n",
    "\n",
    "Let's only do this on a sample of our parameters as it would be quite long otherwise."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-01-23T03:35:07.687016Z",
     "iopub.status.busy": "2021-01-23T03:35:07.686165Z",
     "iopub.status.idle": "2021-01-23T03:35:07.689601Z",
     "shell.execute_reply": "2021-01-23T03:35:07.690178Z"
    }
   },
   "outputs": [],
   "source": [
    "results = []"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-01-23T03:35:07.692684Z",
     "iopub.status.busy": "2021-01-23T03:35:07.691870Z",
     "iopub.status.idle": "2021-01-23T03:35:11.750962Z",
     "shell.execute_reply": "2021-01-23T03:35:11.750606Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "CPU times: user 70.4 ms, sys: 0 ns, total: 70.4 ms\n",
      "Wall time: 4.05 s\n"
     ]
    }
   ],
   "source": [
    "%%time\n",
    "for parameters in input_params.values[:10]:\n",
    "    result = costly_simulation(parameters)\n",
    "    results.append(result)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-01-23T03:35:11.754651Z",
     "iopub.status.busy": "2021-01-23T03:35:11.754132Z",
     "iopub.status.idle": "2021-01-23T03:35:11.755950Z",
     "shell.execute_reply": "2021-01-23T03:35:11.756309Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[1.6219277710024598,\n",
       " 2.6294174907281387,\n",
       " 1.6992598555755398,\n",
       " 2.3772828223470723,\n",
       " 2.282726556895965,\n",
       " 1.8349686663088498,\n",
       " 1.3772989989694402,\n",
       " 1.8685150268891237,\n",
       " 1.9133465756424406,\n",
       " 1.411757265743467]"
      ]
     },
     "execution_count": 7,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "results"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Note that this is not very clever as we can easily parallelize code. \n",
    "\n",
    "There are many ways to parallelize this function in Python with libraries like `multiprocessing`, `concurrent.futures`, `joblib` or others.  These are good first steps.  Dask is a good second step, especially when you want to scale across many machines.\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Use [Dask Delayed](http://dask.pydata.org/en/latest/delayed.html) to make our function lazy\n",
    "\n",
    "We can call `dask.delayed` on our funtion to make it lazy.  Rather than compute its result immediately, it records what we want to compute as a task into a graph that we'll run later on parallel hardware. Using `dask.delayed` is a relatively straightforward way to parallelize an existing code base, even if the computation isn't embarrassingly parallel like this one. \n",
    "\n",
    "Calling these lazy functions is now almost free.  In the cell below we only construct a simple graph."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-01-23T03:35:11.758075Z",
     "iopub.status.busy": "2021-01-23T03:35:11.757645Z",
     "iopub.status.idle": "2021-01-23T03:35:11.761274Z",
     "shell.execute_reply": "2021-01-23T03:35:11.761659Z"
    }
   },
   "outputs": [],
   "source": [
    "import dask\n",
    "lazy_results = []"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-01-23T03:35:11.763381Z",
     "iopub.status.busy": "2021-01-23T03:35:11.762985Z",
     "iopub.status.idle": "2021-01-23T03:35:11.772774Z",
     "shell.execute_reply": "2021-01-23T03:35:11.773201Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "CPU times: user 918 µs, sys: 0 ns, total: 918 µs\n",
      "Wall time: 6.59 ms\n"
     ]
    }
   ],
   "source": [
    "%%time\n",
    "\n",
    "for parameters in input_params.values[:10]:\n",
    "    lazy_result = dask.delayed(costly_simulation)(parameters)\n",
    "    lazy_results.append(lazy_result)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-01-23T03:35:11.778609Z",
     "iopub.status.busy": "2021-01-23T03:35:11.774623Z",
     "iopub.status.idle": "2021-01-23T03:35:11.787116Z",
     "shell.execute_reply": "2021-01-23T03:35:11.787424Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "Delayed('costly_simulation-e05f66a9-2585-4184-9fa0-3bfdf632d4a4')"
      ]
     },
     "execution_count": 10,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "lazy_results[0]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Run in parallel\n",
    "\n",
    "The `lazy_results` list contains information about ten calls to `costly_simulation` that have not yet been run.  Call `.compute()` when you want your result as normal Python objects.\n",
    "\n",
    "If you started `Client()` above then you may want to watch the status page during computation."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-01-23T03:35:11.789510Z",
     "iopub.status.busy": "2021-01-23T03:35:11.788914Z",
     "iopub.status.idle": "2021-01-23T03:35:13.413651Z",
     "shell.execute_reply": "2021-01-23T03:35:13.413184Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "CPU times: user 51.9 ms, sys: 0 ns, total: 51.9 ms\n",
      "Wall time: 1.62 s\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "(1.6219277710024598,\n",
       " 2.6294174907281387,\n",
       " 1.6992598555755398,\n",
       " 2.3772828223470723,\n",
       " 2.282726556895965,\n",
       " 1.8349686663088498,\n",
       " 1.3772989989694402,\n",
       " 1.8685150268891237,\n",
       " 1.9133465756424406,\n",
       " 1.411757265743467)"
      ]
     },
     "execution_count": 11,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "%time dask.compute(*lazy_results)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Notice that this was faster than running these same computations sequentially with a for loop.  "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We can now run this on all of our input parameters:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-01-23T03:35:13.419099Z",
     "iopub.status.busy": "2021-01-23T03:35:13.418700Z",
     "iopub.status.idle": "2021-01-23T03:35:13.567613Z",
     "shell.execute_reply": "2021-01-23T03:35:13.567077Z"
    }
   },
   "outputs": [],
   "source": [
    "import dask\n",
    "lazy_results = []\n",
    "\n",
    "for parameters in input_params.values:\n",
    "    lazy_result = dask.delayed(costly_simulation)(parameters)\n",
    "    lazy_results.append(lazy_result)\n",
    "    \n",
    "futures = dask.persist(*lazy_results)  # trigger computation in the background"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "To make this go faster, we can add additional workers.\n",
    "\n",
    "(although we're still only working on our local machine, this is more practical when using an actual cluster)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-01-23T03:35:13.589006Z",
     "iopub.status.busy": "2021-01-23T03:35:13.587950Z",
     "iopub.status.idle": "2021-01-23T03:35:13.594990Z",
     "shell.execute_reply": "2021-01-23T03:35:13.594321Z"
    }
   },
   "outputs": [],
   "source": [
    "client.cluster.scale(10)  # ask for ten 4-thread workers"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "By looking at the Dask dashboard we can see that Dask spreads this work around our cluster, managing load balancing, dependencies, etc..\n",
    "\n",
    "Then get the result:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-01-23T03:35:13.612952Z",
     "iopub.status.busy": "2021-01-23T03:35:13.612534Z",
     "iopub.status.idle": "2021-01-23T03:35:23.636341Z",
     "shell.execute_reply": "2021-01-23T03:35:23.637097Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "(1.6219277710024598,\n",
       " 2.6294174907281387,\n",
       " 1.6992598555755398,\n",
       " 2.3772828223470723,\n",
       " 2.282726556895965)"
      ]
     },
     "execution_count": 14,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "results = dask.compute(*futures)\n",
    "results[:5]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Using the [Futures API](http://dask.pydata.org/en/latest/futures.html)\n",
    "\n",
    "The same example can be implemented using Dask's Futures API by using the `client` object itself.  For our use case of applying a function across many inputs both Dask delayed and Dask Futures are equally useful.  The Futures API is a little bit different because it starts work immediately rather than being completely lazy.\n",
    "\n",
    "For example, notice that work starts immediately in the cell below as we submit work to the cluster:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-01-23T03:35:23.645861Z",
     "iopub.status.busy": "2021-01-23T03:35:23.639736Z",
     "iopub.status.idle": "2021-01-23T03:35:23.932140Z",
     "shell.execute_reply": "2021-01-23T03:35:23.933203Z"
    }
   },
   "outputs": [],
   "source": [
    "futures = []\n",
    "for parameters in input_params.values:\n",
    "    future = client.submit(costly_simulation, parameters)\n",
    "    futures.append(future)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We can explicitly wait until this work is done and gather the results to our local process by calling `client.gather`:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-01-23T03:35:23.941820Z",
     "iopub.status.busy": "2021-01-23T03:35:23.941387Z",
     "iopub.status.idle": "2021-01-23T03:35:30.579878Z",
     "shell.execute_reply": "2021-01-23T03:35:30.579123Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[1.6219277710024598,\n",
       " 2.6294174907281387,\n",
       " 1.6992598555755398,\n",
       " 2.3772828223470723,\n",
       " 2.282726556895965]"
      ]
     },
     "execution_count": 16,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "results = client.gather(futures)\n",
    "results[:5]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "But the code above can be run in fewer lines with `client.map()` function, allowing to call a given function on a list of parameters.\n",
    "\n",
    "As for delayed, we can only start the computation and not wait for results by not calling `client.gather()` right now.\n",
    "\n",
    "It shall be noted that as Dask cluster has already performed tasks launching `costly_simulation` with Futures API on the given input parameters, the call to `client.map()` won't actually trigger any computation, and just retrieve already computed results."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-01-23T03:35:30.588685Z",
     "iopub.status.busy": "2021-01-23T03:35:30.588247Z",
     "iopub.status.idle": "2021-01-23T03:35:30.651164Z",
     "shell.execute_reply": "2021-01-23T03:35:30.651572Z"
    }
   },
   "outputs": [],
   "source": [
    "futures = client.map(costly_simulation, input_params.values)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Then just get the results later:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-01-23T03:35:30.654664Z",
     "iopub.status.busy": "2021-01-23T03:35:30.653603Z",
     "iopub.status.idle": "2021-01-23T03:35:30.756562Z",
     "shell.execute_reply": "2021-01-23T03:35:30.755168Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "500"
      ]
     },
     "execution_count": 18,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "results = client.gather(futures)\n",
    "len(results)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-01-23T03:35:30.760174Z",
     "iopub.status.busy": "2021-01-23T03:35:30.759759Z",
     "iopub.status.idle": "2021-01-23T03:35:30.764208Z",
     "shell.execute_reply": "2021-01-23T03:35:30.763697Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "1.6219277710024598\n"
     ]
    }
   ],
   "source": [
    "print(results[0])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We encourage you to watch the [dashboard's status page](../proxy/8787/status) to watch on going computation."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Doing some analysis on the results\n",
    "\n",
    "One of the interests of Dask here, outside from API simplicity, is that you are able to gather the result for all your simulations in one call.  There is no need to implement a complex mechanism or to write individual results in a shared file system or object store.\n",
    "\n",
    "Just get your result, and do some computation."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Here, we will just get the results and expand our initial dataframe to have a nice view of parameters vs results for our computation"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-01-23T03:35:30.769029Z",
     "iopub.status.busy": "2021-01-23T03:35:30.768427Z",
     "iopub.status.idle": "2021-01-23T03:35:30.789878Z",
     "shell.execute_reply": "2021-01-23T03:35:30.790557Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>param_a</th>\n",
       "      <th>param_b</th>\n",
       "      <th>param_c</th>\n",
       "      <th>param_d</th>\n",
       "      <th>result</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>12</th>\n",
       "      <td>0.779835</td>\n",
       "      <td>0.091715</td>\n",
       "      <td>0.399588</td>\n",
       "      <td>0.905207</td>\n",
       "      <td>2.176346</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>279</th>\n",
       "      <td>0.763126</td>\n",
       "      <td>0.257677</td>\n",
       "      <td>0.572547</td>\n",
       "      <td>0.512945</td>\n",
       "      <td>2.106295</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>188</th>\n",
       "      <td>0.323628</td>\n",
       "      <td>0.218317</td>\n",
       "      <td>0.885703</td>\n",
       "      <td>0.016643</td>\n",
       "      <td>1.444291</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>325</th>\n",
       "      <td>0.806115</td>\n",
       "      <td>0.693413</td>\n",
       "      <td>0.649505</td>\n",
       "      <td>0.090475</td>\n",
       "      <td>2.239508</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>22</th>\n",
       "      <td>0.653933</td>\n",
       "      <td>0.660658</td>\n",
       "      <td>0.014027</td>\n",
       "      <td>0.476105</td>\n",
       "      <td>1.804723</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "      param_a   param_b   param_c   param_d    result\n",
       "12   0.779835  0.091715  0.399588  0.905207  2.176346\n",
       "279  0.763126  0.257677  0.572547  0.512945  2.106295\n",
       "188  0.323628  0.218317  0.885703  0.016643  1.444291\n",
       "325  0.806115  0.693413  0.649505  0.090475  2.239508\n",
       "22   0.653933  0.660658  0.014027  0.476105  1.804723"
      ]
     },
     "execution_count": 20,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "output = input_params.copy()\n",
    "output['result'] = pd.Series(results, index=output.index)\n",
    "output.sample(5)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Then we can do some nice statistical plots or save result locally with pandas interface here"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-01-23T03:35:30.795090Z",
     "iopub.status.busy": "2021-01-23T03:35:30.794149Z",
     "iopub.status.idle": "2021-01-23T03:35:31.808734Z",
     "shell.execute_reply": "2021-01-23T03:35:31.809602Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "<AxesSubplot:>"
      ]
     },
     "execution_count": 21,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "%matplotlib inline\n",
    "output['result'].plot()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-01-23T03:35:31.813172Z",
     "iopub.status.busy": "2021-01-23T03:35:31.812759Z",
     "iopub.status.idle": "2021-01-23T03:35:31.817246Z",
     "shell.execute_reply": "2021-01-23T03:35:31.816869Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "1.9894512814510577"
      ]
     },
     "execution_count": 22,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "output['result'].mean()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-01-23T03:35:31.821889Z",
     "iopub.status.busy": "2021-01-23T03:35:31.821458Z",
     "iopub.status.idle": "2021-01-23T03:35:31.837685Z",
     "shell.execute_reply": "2021-01-23T03:35:31.838134Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "247\n"
     ]
    }
   ],
   "source": [
    "filtered_output = output[output['result'] > 2]\n",
    "print(len(filtered_output))\n",
    "filtered_output.to_csv('/tmp/simulation_result.csv')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Handling very large simulation with [Bags](http://dask.pydata.org/en/latest/bag.html)\n",
    "\n",
    "The methods above work well for a size of input parameters up to about 100,000.  Above that, the Dask scheduler has trouble handling the amount of tasks to schedule to workers.  The solution to this problem is to bundle many parameters into a single task.\n",
    "You could do this either by making a new function that operated on a batch of parameters and using the delayed or futures APIs on that function.  You could also use the Dask Bag API.  This is described more in the documentation about [avoiding too many tasks](http://dask.pydata.org/en/latest/delayed-best-practices.html#avoid-too-many-tasks).\n",
    "\n",
    "Dask Bags hold onto large sequences in a few partitions.  We can convert our `input_params` sequence into a `dask.bag` collection, asking for fewer partitions (so at most 100,000, which is already huge), and apply our function on every item of the bag."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-01-23T03:35:31.841614Z",
     "iopub.status.busy": "2021-01-23T03:35:31.841209Z",
     "iopub.status.idle": "2021-01-23T03:35:31.997613Z",
     "shell.execute_reply": "2021-01-23T03:35:31.998016Z"
    }
   },
   "outputs": [],
   "source": [
    "import dask.bag as db\n",
    "b = db.from_sequence(list(input_params.values), npartitions=100)\n",
    "b = b.map(costly_simulation)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-01-23T03:35:32.001347Z",
     "iopub.status.busy": "2021-01-23T03:35:32.000935Z",
     "iopub.status.idle": "2021-01-23T03:35:40.706652Z",
     "shell.execute_reply": "2021-01-23T03:35:40.706247Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "CPU times: user 644 ms, sys: 87.9 ms, total: 732 ms\n",
      "Wall time: 8.7 s\n"
     ]
    }
   ],
   "source": [
    "%time results_bag = b.compute()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Looking on Dashboard here, you should see only 100 tasks to run instead of 500, each taking 5x more time in average, because each one is actually calling our function 5 times."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-01-23T03:35:40.710732Z",
     "iopub.status.busy": "2021-01-23T03:35:40.710288Z",
     "iopub.status.idle": "2021-01-23T03:35:40.723565Z",
     "shell.execute_reply": "2021-01-23T03:35:40.723163Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 26,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "np.all(results) == np.all(results_bag)"
   ]
  }
 ],
 "metadata": {
  "anaconda-cloud": {},
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.6"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
